{
  "contractName": "IUniswapV2Factory",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        }
      ],
      "name": "getPair",
      "outputs": [
        {
          "internalType": "address",
          "name": "pair",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "metadata": "{\"compiler\":{\"version\":\"0.6.6+commit.6c089d02\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{}},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"/home/trinh.van.tan/phonefarm-project/phonefarm-contracts/contracts/PreSale.sol\":\"IUniswapV2Factory\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"/home/trinh.van.tan/phonefarm-project/phonefarm-contracts/contracts/PhoneToken.sol\":{\"keccak256\":\"0x7713c3c2c9067787ad4eedd70cdf546987b6a304e23614e86aad261b08ded9ee\",\"urls\":[\"bzz-raw://a89f574b6b162f8405dd4162fc8f00314b2b939849993b1159de6bc4b3ec6ce0\",\"dweb:/ipfs/QmW86HBpgfQjuhpcpcfqn3PTFAy8ivufaPpixCH4KShmMZ\"]},\"/home/trinh.van.tan/phonefarm-project/phonefarm-contracts/contracts/PreSale.sol\":{\"keccak256\":\"0xfe78c0eb06c0e520e672e5dbcf408a2c3b1d1666a2bbb69fbf39a27f44c9bb4a\",\"urls\":[\"bzz-raw://dbd50270c6375ffa2cf8460ffad4498c5c7356fb32a4bd451385f149d66e2ac7\",\"dweb:/ipfs/QmT62HmPtg3w6WUNm3E7ULtcJoTmJbTXxSrFE1gvd6uqLz\"]},\"@openzeppelin/contracts/GSN/Context.sol\":{\"keccak256\":\"0xdb26cbf4d028490f49831a7865c2fe1b28db44b535ca8d343785a3b768aae183\",\"urls\":[\"bzz-raw://840b14ce0315c47d49ba328f1f9fa7654ded1c9e1559e6c5e777a7b2dc28bf0a\",\"dweb:/ipfs/QmTLLabn4wcfGro9LEmUXUN2nwKqZSotXMvjDCLXEnLtZP\"]},\"@openzeppelin/contracts/access/Ownable.sol\":{\"keccak256\":\"0x4bd6402ca6b3419008c2b482aff54e66836e8cb4eba2680e42ac5884ae6424fc\",\"urls\":[\"bzz-raw://8f9f711fb8d0d92aeea1c327e3845d13ca1fa8f142e47f8723cd5b3106fb29a3\",\"dweb:/ipfs/QmVQUReDW9f4zGqhizwHnyU8EntMs95tbASdqkGncnikba\"]},\"@openzeppelin/contracts/math/SafeMath.sol\":{\"keccak256\":\"0x9a9cf02622cd7a64261b10534fc3260449da25c98c9e96d1b4ae8110a20e5806\",\"urls\":[\"bzz-raw://2df142592d1dc267d9549049ee3317fa190d2f87eaa565f86ab05ec83f7ab8f5\",\"dweb:/ipfs/QmSkJtcfWo7c42KnL5hho6GFxK6HRNV91XABx1P7xDtfLV\"]},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"keccak256\":\"0x91e0bd6a6762d2a1700dab0849de8422611355100576c4beef1e80d82a4104a0\",\"urls\":[\"bzz-raw://73bbd77af0a8b07255d2ffa20728bcf13b116007c9ddac5d37046cfabb0e1e02\",\"dweb:/ipfs/QmRgZgWCWCSMTTaok6o4QvWA6MgB4goS8qpb3sN7bAvaZ9\"]},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"keccak256\":\"0x5c26b39d26f7ed489e555d955dcd3e01872972e71fdd1528e93ec164e4f23385\",\"urls\":[\"bzz-raw://efdc632af6960cf865dbc113665ea1f5b90eab75cc40ec062b2f6ae6da582017\",\"dweb:/ipfs/QmfAZFDuG62vxmAN9DnXApv7e7PMzPqi4RkqqZHLMSQiY5\"]},\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\":{\"keccak256\":\"0xf3b30f8a49631420635a8c35daacfcaa338012755f18a76fdd118730256f9a27\",\"urls\":[\"bzz-raw://0d7de652204c2ee291a61aa984103dfc7ae4392d651fbbc44a0079caee7c69a3\",\"dweb:/ipfs/Qmcw1cQnq9eWDnrCBwU3TNyqLfTMUFg5YKpYUkELoMPuUE\"]},\"@openzeppelin/contracts/utils/Address.sol\":{\"keccak256\":\"0xf5fa8cbdffa5ef8be49b246b5628facc30b71707e78a45d80d93b64eff3fe390\",\"urls\":[\"bzz-raw://774e78a9ff32792cc95db4d2ceaf3a7965bb7f0bea5e6cb7cff182b450d44b37\",\"dweb:/ipfs/QmRRMC4uj7eAcLW7chynA3sNEYULMFazdLwQHKHQPyzAbA\"]}},\"version\":1}",
  "bytecode": "0x",
  "deployedBytecode": "0x",
  "immutableReferences": {},
  "sourceMap": "",
  "deployedSourceMap": "",
  "source": "// SPDX-License-Identifier: BoomerTeam\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./PhoneToken.sol\";\n\ninterface IUniswapV2Pair {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n}\n\ninterface IUniswapV2Factory {\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n}\n\ncontract PreSale is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for PhoneToken;\n\n    address public WETH;\n    address public uniswapV2FactoryAddress;\n\n    mapping(address => bool) public tokensList;\n\n    // The PHONE token!\n    PhoneToken public phone;\n    // Rate of token with ETH\n    uint256 public rate;\n    // lock presale\n    bool public lock;\n\n    modifier isAccepted(address _token) {\n        require(_token != WETH && _token != address(phone), \"Token is not accepted!\");\n        _;\n    }\n\n    // Constructor\n    constructor(PhoneToken _phone, address _weth, address _uniswapV2FactoryAddress) public {\n        phone = _phone;\n        rate = 1000;\n        lock = false;\n        WETH = _weth;\n        uniswapV2FactoryAddress = _uniswapV2FactoryAddress;\n    }\n\n    // Functions\n    function lockIn() public onlyOwner {\n        lock = true;\n    }\n\n    function unlock() public onlyOwner {\n        lock = false;\n    }\n\n    /**\n     * @dev change rate of token PHONE\n     * @param _newRate is new rate of token PHONE with ETH\n     */\n    function changeRate(uint256 _newRate) public onlyOwner {\n        require(_newRate > 0, \"_newRate must be greater than 0\");\n        rate = _newRate;\n    }\n\n    event BuyToken(address indexed buyer, uint256 phoneAmount, uint256 rate);\n\n    /**\n     * @dev add token to tokensList\n     * @param _token is address of the token\n     */\n    function addToken(address _token) public onlyOwner isAccepted(_token) {\n        require(!tokensList[_token], \"This token is already added!\");\n        tokensList[_token] = true;\n    }\n\n    /**\n     * @dev remove token from tokensList\n     * @param _token is address of the token\n     */\n    function removeToken(address _token) public onlyOwner isAccepted(_token) {\n        require(tokensList[_token], \"This token is already removed!\");\n        tokensList[_token] = false;\n    }\n\n    /**\n     * @dev buy PHONE by ERRC20\n     * @param _token is address of the token\n     * @param _amount is amount of ERC20 token\n     */\n    function buyPhoneTokenByERC20(address _token, uint256 _amount) public isAccepted(_token){\n        require(!lock, \"not in lock state\");\n        require(tokensList[_token], \"Token is not accepted!\");\n\n        uint256 preSaleBal = phone.balanceOf(address(this));\n        uint256 phoneAmount = calculatePhoneTokenAmount(_token, _amount);\n\n        require(\n            phoneAmount <= preSaleBal,\n            \"total phone token purchased must be less than preSaleBal\"\n        );\n\n        IERC20(_token).transferFrom(msg.sender, address(this), _amount);\n        phone.safeTransfer(msg.sender, phoneAmount);\n        emit BuyToken(msg.sender, phoneAmount, rate);\n    }\n\n\n    function erc20ToPhoneToken(address _token, uint256 _amount) public view isAccepted(_token) returns (uint256){\n        require(!lock, \"not in lock state\");\n        require(tokensList[_token], \"Token is not accepted!\");\n\n        uint256 phoneAmount = calculatePhoneTokenAmount(_token, _amount);\n        return phoneAmount;\n    }\n\n    function calculatePhoneTokenAmount(address _token, uint256 _amount) internal view returns (uint256) {\n\n        address pairAddress = IUniswapV2Factory(uniswapV2FactoryAddress).getPair(_token, WETH);\n        (uint112 _reserve0, uint112 _reserve1,) = IUniswapV2Pair(pairAddress).getReserves();\n\n        uint256 reserve0 = uint256(_reserve0);\n        uint256 reserve1 = uint256(_reserve1);\n\n        uint256 phoneAmount;\n        if(_token < WETH) {\n            phoneAmount = (_amount.mul(reserve1).div(reserve0)).mul(rate);\n        } else {\n            phoneAmount = (_amount.mul(reserve0).div(reserve1)).mul(rate);\n        }\n\n        return phoneAmount;\n    }\n    /**\n     * @dev function buy token PHONE\n     */\n    function buyTokenPhone() public payable {\n        require(!lock, \"not in lock state\");\n        uint256 preSaleBal = phone.balanceOf(address(this));\n        uint256 phoneAmount = (msg.value).mul(rate);\n        require(\n            phoneAmount <= preSaleBal,\n            \"total phone token purchased must be less than preSaleBal\"\n        );\n        phone.safeTransfer(msg.sender, phoneAmount);\n        emit BuyToken(msg.sender, phoneAmount, rate);\n    }\n\n    /**\n     * @dev get balance ETH of contract\n     */\n    function getBalanceETH() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @dev get balanceOf PHONE token of contract\n     */\n    function getBalancePHONE() public view returns (uint256) {\n        return phone.balanceOf(address(this));\n    }\n\n    /**\n     * @dev function withdraw ETH to account owner\n     * @param _amount is amount withdraw\n     */\n    function withdrawETH(uint256 _amount) public onlyOwner {\n        require(_amount > 0, \"_amount must be greater than 0\");\n        require(\n            address(this).balance >= _amount,\n            \"_amount must be less than the ETH balance of the contract\"\n        );\n        msg.sender.transfer(_amount);\n    }\n\n    /**\n     * @dev function withdraw PHONE token to account owner\n     * @param _amount is amount withdraw\n     */\n    function withdrawPHONE(uint256 _amount) public onlyOwner {\n        require(_amount > 0, \"_amount must be greater than 0\");\n        require(\n            phone.balanceOf(address(this)) >= _amount,\n            \"_amount must be less than the PHONE token balanceOf the contract\"\n        );\n        phone.safeTransfer(msg.sender, _amount);\n    }\n\n    /**\n     * @dev function withdraw ERC20 token to account owner\n     * @param _token is address of the token\n     * @param _amount is amount withdraw\n     */\n    function withdrawERC20(address _token ,uint256 _amount) public onlyOwner isAccepted(_token) {\n        require(_amount > 0, \"_amount must be greater than 0\");\n        require(tokensList[_token], \"Token is not accepted!\");\n        require(\n            IERC20(_token).balanceOf(address(this)) >= _amount,\n            \"The balance is not enough!\"\n        );\n        IERC20(_token).transfer(msg.sender, _amount);\n    }\n\n    event Received(address, uint256);\n\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n}\n",
  "compiler": {
    "name": "solc",
    "version": "0.6.6+commit.6c089d02.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "3.2.5",
  "updatedAt": "2020-10-27T01:28:31.701Z",
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  }
}
